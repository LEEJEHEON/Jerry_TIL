# DB 옵티마이저 
- 데이터베이스 옵티마이저는 SQL 쿼리를 가장 빠르고 효율적으로 수행할 최적의 처리 경로(실행 계획)를 생성하는 DBMS의 핵심 엔진
- 사용자가 쿼리를 작성하면 바로 실행하지 않고, 옵티마이저가 여러 가능한 실행 계획을 만들고 비용(디스크 I/O, CPU 사용 등)을 계산해 가장 효율적인 경로를 선택해 실행한다.

## 💡옵티마이저의 역할
- SQL 쿼리를 어떻게 실행할지 결정하여 쿼리 성능을 최적화
- 통계 정보와 테이블 구조, 인덱스 유무, 조인 순서 등 다양한 요소를 고려해 실행 계획 후보를 생성
- 각 실행 계획의 비용을 산정하고 비용이 가장 낮은 계획을 선택해 쿼리를 수행

## 💡옵티마이저 유형
- 규칙 기반 옵티마이저(Rule-Based Optimizer, RBO): 사전에 정의된 규칙을 통해 최적 경로를 선택하는 방식으로 상대적으로 단순 <br>
(현재 많이 사용 안함)
- 비용 기반 옵티마이저(Cost-Based Optimizer, CBO): 대부분 현대 DBMS에서 사용하며, 통계 정보를 이용해 예상 비용을 산정하고 최저 비용 실행 계획을 선택 <br>
(더 정교하고 현실적인 최적화를 수행)

## 💡옵티마이저의 비용 기반 모델이 작동하는 방법
- 비용 기반 옵티마이저(Cost-Based Optimizer, CBO)는 여러 실행 계획 후보를 생성하고, 각 계획에 대해 예상되는 비용을 계산하여 가장 비용이 낮은 실행 계획을 선택하는 방식
- 비용은 쿼리를 수행하는데 드는 예상 자원 사용량(디스크 I/O, CPU 사용, 메모리 소비 등)과 시간의 합산 개념

### 작동원리
1. 통계 정보 수집
- 옵티마이저는 테이블 크기, 인덱스 유무, 컬럼 통계(데이터 분포, 카디널리티), 그리고 시스템 성능 지표(CPU 속도, 디스크 I/O 속도) 등의 다양한 통계 정보를 활용
- 이러한 통계가 정확할수록 비용 예측이 정밀해지고 최적 실행 계획 산출이 가능해짐.

2. 실행 계획 후보 생성
- 가능한 조인 순서, 인덱스 사용 여부, 접근 경로 등 다양한 쿼리 실행 방식을 조합하여 최대 약 2,000개까지 실행 계획 후보를 생성

3. 비용 산정
- 각 실행 계획 후보에 대해 예상되는 비용을 산정하는데, 비용에는 I/O 비용(디스크 읽기/쓰기), CPU 비용(연산량), 네트워크 비용 등이 포함

4. 최적 계획 선택
- 산정된 비용이 가장 적은 실행 계획을 선택하여 실제 쿼리를 실행
- 이로써 전체 쿼리 수행 시간이 최소화되고 시스템 자원 사용 효율이 극대화

## 💡실행계획(Execution Plan) 읽는 법과 주요 항목
- 실행계획 : 옵티마이저가 SQL 쿼리를 수행할 때 선택한 작업 순서와 방법을 보여주는 것으로, 성능 분석과 쿼리 튜닝에 꼭 필요한 정보

### 실행계획 읽는 법
1. 읽는 순서
- 실행계획은 위에서 아래로 읽으면서, 들여쓰기가 있다면 가장 안쪽 들여쓰기(최하위 작업)부터 시작해 상위 작업으로 올라가면서 해석
- 즉, 먼저 최종적으로 데이터를 추출하는 작업부터 이해하고 그 작업을 수행하기 위한 하위 작업 단계들을 순차적으로 읽는다.

2. 작업 트리 구조
- 실행계획은 여러 작업(Operation)들이 트리구조로 표현
- 각 작업은 부모(Parent)–자식(Child) 관계를 가지며, 하위 작업이 먼저 실행되는 흐름

### 실행계획 주요 항목
- Operation: 수행할 작업 단위로, 테이블 접근, 인덱스 스캔, 조인, 정렬 등 쿼리 수행 단계별 동작 방식이 표시 <br>
예) TABLE ACCESS FULL, INDEX SCAN, NESTED LOOPS JOIN 등
- Name: 작업 대상 객체 이름(테이블명, 인덱스명 등)을 나타냄
- Rows: 해당 작업 단계에서 예상되거나 실제 처리되는 행(row) 수입니다. 이 값이 크면 성능 병목 가능성이 있으니 주의해야 함
- Bytes: 처리되는 데이터 크기(바이트 단위)로, 작업의 부담 정도를 가늠할 수 있음
- Cost: 작업 수행에 대한 예상 비용 지표로, CPU와 I/O 등의 자원 소비 합산 , 낮을수록 효율적인 실행 계획을 의미
- Predicate: 각 작업 단계에서 적용되는 필터 조건이나 조인 조건으로, 쿼리의 세부 조건이 어떻게 처리되는지 확인할 수 있음

### 실행계획 해석 시 주의할 점
- 인덱스 사용 여부 확인: 인덱스가 기대대로 적용되는지 중요
- 조인 방식 이해: 조인 방식(Nested Loops, Hash Join, Sort Merge Join 등)에 따라 성능이 크게 달라짐 
- 필터링 및 정렬 위치: 대량 정렬이나 필터링이 일어나는 작업 단계도 성능에 큰 영향을 준다.

## 💡인덱스·통계 변경이 옵티마이저에 미치는 영향

### 1. 인덱스 변경의 영향
- 인덱스 추가: 새로운 인덱스가 생성되면 옵티마이저는 해당 인덱스를 활용한 실행 계획을 후보로 고려 <br>
예를 들어, WHERE 조건이나 JOIN에 적합한 인덱스가 있으면 테이블 전체 스캔 대신 인덱스 스캔을 선택해 쿼리 성능이 크게 향상될 수 있음
- 인덱스 삭제: 기존에 사용하던 인덱스가 삭제되면 옵티마이저는 더 이상 그 인덱스를 사용할 수 없으므로, 테이블 전체 스캔이나 다른 인덱스를 활용한 실행 계획으로 변경 <이로 인해 쿼리 성능이 저하>
- 인덱스 구조 변경: 복합 인덱스의 컬럼 순서 변경, 인덱스 리빌드 등도 옵티마이저의 실행 계획 선택에 영향을 준다
- 인덱스 남용: 인덱스가 너무 많으면 옵티마이저가 후보 계획을 더 많이 생성해야 하므로, 오히려 최적화 과정이 느려지고, 쓰기 작업(INSERT/UPDATE/DELETE) 성능도 저하될 수 있음. 

### 2. 통계 정보 변경의 영향
- 통계 정보란? >> 테이블의 행 수, 컬럼 값의 분포(카디널리티), NULL 비율, 인덱스 선택도 등 데이터 특성을 요약한 정보
- 통계 정보 갱신: 데이터가 많이 변경된 후 통계를 갱신하면, 옵티마이저가 최신 데이터 분포를 반영해 더 정확한 실행 계획을 세울 수 있다. <br>
예를 들어, 특정 컬럼의 값이 매우 다양해졌다면 인덱스 사용이 더 유리하다고 판단할 수 있다.
- 통계 정보 부정확: 통계가 오래되어 실제 데이터와 차이가 크면, 옵티마이저가 비효율적인 실행 계획(예: 인덱스 대신 테이블 전체 스캔)을 선택할 수 있음. 

## 💡옵티마이저 튜닝 시 체크리스트나 우선순위

### 1. 정확한 통계 정보 수집
- 테이블, 인덱스, 컬럼의 통계 정보를 최신 상태로 유지
- 데이터가 많이 변경된 후에는 반드시 통계를 갱신해야 옵티마이저가 올바른 실행 계획을 선택

### 2. 적절한 인덱스 설계 및 관리
- 쿼리 조건에 맞는 인덱스가 있는지 확인하고, 불필요한 인덱스는 제거
- 복합 인덱스, 인덱스 컬럼 순서, 인덱스 사용 여부를 점검

### 3. 실행 계획 분석 및 검토
- EXPLAIN PLAN 또는 AUTOTRACE로 실행 계획을 확인
- 테이블 전체 스캔, 비효율적인 조인 방식, 불필요한 정렬/필터링이 있는지 체크

### 4. 옵티마이저 모드 및 파라미터 설정
- 목적에 맞는 옵티마이저 모드(ALL_ROWS, FIRST_ROWS_N 등)를 설정
- DBMS별 파라미터(예: 쿼리 캐시, 병렬 처리 등)도 점검

### 5. SQL 구조 및 작성 방식 개선
- 불필요한 서브쿼리, 중복 조인, 복잡한 조건문을 단순화
- WHERE, JOIN 조건에 인덱스가 적용되는지 확인

### 6. DB 설계 및 물리적 구조 점검
- 파티션, 클러스터, 인덱스 조직 테이블(IOT), 머티리얼라이즈드 뷰(MV) 등 DBMS 기능을 활용

### 7. 힌트(Hint) 사용 여부 결정
- 옵티마이저가 비효율적인 실행 계획을 선택할 때만 힌트를 사용
- 힌트는 유지보수에 영향을 줄 수 있으니 꼭 필요한 경우에만 적용