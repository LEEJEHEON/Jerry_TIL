# 트래픽

## 💡 트래픽이란, 
- DB 트래픽은 데이터베이스 서버에서 오가는 데이터의 양을 의미
- 즉, 여러 사용자가 데이터베이스에 쿼리를 보내고, 결과를 받아올 때 발생하는 총 데이터 전송량
    - 단위: 보통 바이트(예: KB, MB, GB)로 측정
    - 발생 원인: 쿼리 실행, 데이터 읽기/쓰기, 동시접속자 증가 등으로 트래픽이 늘어남

## 💡 트래픽과 대역폭의 차이
- 트래픽: 일정 기간 동안 실제로 오간 데이터의 총량
- 대역폭: 초당 처리할 수 있는 데이터의 최대량 (예: 1Gbps)
> 트래픽이 대역폭을 초과하면 서버가 느려지거나 장애가 발생할 수 있다.

## 💡 DB 트래픽이 중요한 이유
- 성능 관리: 트래픽이 많아지면 서버 과부하, 응답 지연, 장애가 발생할 수 있습니다.
- 비용 관리: 클라우드나 호스팅 환경에서는 트래픽이 많을수록 비용이 증가
- 보안: 비정상적으로 많은 트래픽은 DDoS(분산 서비스 거부) 공격의 신호

## 💡 트래픽 패턴 (OLTP, OLAP)

### OLTP (Online Transaction Processing)
- 목적: 실시간 트랜잭션 처리에 최적화 (예: 주문, 결제, 계좌 이체)
- 트래픽 패턴: 짧고 빈번한 쿼리, 주로 쓰기와 읽기가 모두 중요
- 특징:
    - 데이터 무결성, 빠른 응답 시간
    - 정규화된 스키마
    - 소량의 데이터 처리
    - 예시: 은행, 쇼핑몰, 항공 예약 시스템
- 쓰기 집중형: OLTP처럼 실시간 데이터 입력, 수정, 삭제가 많음. 트랜잭션 안정성과 빠른 쓰기 성능이 중요함.

### OLAP (Online Analytical Processing)
- 목적: 대량 데이터 분석 및 집계에 최적화 (예: 매출 분석, 마케팅 리포트)
- 트래픽 패턴: 복잡한 쿼리, 주로 읽기 집중형
- 특징 : 
    - 다차원 분석, 집계/그룹화 쿼리
    - 반정규화된 스키마(스타/스노우플레이크)
    - 대량의 데이터 처리
    - 예시: BI 도구, 데이터 웨어하우스
- 읽기 집중형: OLAP처럼 분석, 리포트, 집계 쿼리가 많음. 대량 데이터 조회가 빠른 구조(컬럼 지향 DB 등)로 설계됨.

###  비교 

| 기준  | OLTP (쓰기/읽기 혼합)       |OLAP (읽기 집중)       |
|--------|------------|------------|
| 목적 | 실시간 트랜잭션 |데이터 분석 |
| 트래픽 패턴 |	짧고 빈번한 쿼리 |복잡한 집계 쿼리|
| 데이터 구조 | 정규화 |반정규화 |
| 처리량 | 소량 |대량 |
| 예시 | 주문, 결제 |리포트, 분석 |

## 💡 트래픽 측정 방법
쿼리 로그, 연결 수, TPS(Transactions Per Second), 지연 시간, QPS(Query Per Second) 등 주요 측정 지표 학습.
### 1. 쿼리 로그 
- 역할: 어떤 쿼리가 언제, 얼마나 자주 실행되는지 기록
- 활용: 느린 쿼리(slow query)나 자주 실행되는 쿼리를 찾아 성능 개선에 활용

### 2. 연결 수 (Connection Count)
- 역할: 동시에 데이터베이스에 접속한 클라이언트(사용자, 서비스)의 수를 측정
- 활용: 연결 수가 많으면 트래픽이 높다는 신호이며, 연결 제한이나 풀(pool) 설정이 필요할 수 있음

### 3. TPS (Transactions Per Second)
- 역할: 초당 처리되는 트랜잭션의 수
- 활용: OLTP 환경에서 실시간 처리량을 파악하는 데 중요합니다. TPS가 높을수록 서버 부하가 커진다

### 4. QPS (Queries Per Second)
- 역할: 초당 실행되는 쿼리의 수
- 활용: OLAP 환경이나 대량 조회 서비스에서 조회 부하를 측정하는 데 사용

### 5. 지연 시간(Latency)
- 역할: 쿼리 요청부터 응답까지 걸리는 시간
- 활용: 지연 시간이 길면 병목이나 장애의 신호일 수 있습니다. 빠른 응답이 중요한 서비스에서 핵심 지표

### 기타 지표
- 에러율(Error Rate): 실패한 쿼리나 트랜잭션의 비율을 측정
- 포화 상태(Saturation): CPU, 메모리, 디스크 등 리소스가 얼마나 가득 찼는지 확인 -> 병목 구간을 찾는데 중요요


## ❓ QnA

### 🙋‍♂️ 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?
💁 트래픽이 급증하면 데이터베이스는 여러 가지 전략으로 부하를 관리할 수 있습니다. 

1. Scale-Up (서버 스펙 업그레이드)
- 방법: CPU, 메모리, 디스크 등 하드웨어 성능을 높여 단일 서버가 더 많은 트래픽을 처리하도록 함
- 장점: 관리가 단순하고 직접적인 성능 향상.
- 단점: 비용이 많이 들고, 물리적 한계가 있음.

2. Scale-Out (수평적 확장)
- 방법: 여러 DB 서버를 추가해 트래픽을 분산 처리 / 로드밸런서와 Replication(Master/Slave 구조)로 읽기/쓰기를 분리
- 장점: 확장성이 높고, 장애 시 서비스 연속성 유지.
- 단점: 관리 복잡성 증가, 데이터 일관성 유지가 필요.

3. Connection Pooling
- 방법: 애플리케이션과 DB 사이의 연결을 미리 만들어두고 재사용하여, 매번 연결/해제 오버헤드를 줄임 
- 장점: 연결 생성 비용 절감, 동시접속자 증가에도 효율적 대응.

4. CQRS (Command Query Responsibility Segregation)
- 방법: 읽기와 쓰기 작업을 서로 다른 DB로 분리해 각각 최적화
- 장점: 읽기/쓰기 성능 최적화, 동시성 문제 감소.
- 단점: 아키텍처 복잡성 증가, 데이터 동기화 필요.

5. <b>Replication (복제) </b>
- 방법: Master DB는 쓰기, Slave DB는 읽기 전용으로 분리해 읽기 트래픽을 분산
- 장점: 읽기 부하 분산, 장애 대응력 향상

6. 샤딩(Sharding)
- 방법: 데이터를 여러 DB에 분산 저장해, 각 DB가 일부 트래픽만 처리하도록 함
- 장점: 대용량 데이터/트래픽 분산, 확장성 높음
- 단점: 구현과 관리가 복잡함.

7. 캐싱(Cache)
- 방법: 자주 조회되는 데이터를 메모리 캐시(Redis, Memcached 등)에 저장해 DB 부하를 줄임
- 장점: 조회 속도 향상, DB 트래픽 감소

8. <b>모니터링 및 튜닝 </b>
- 방법: 트래픽 지표(TPS, QPS, 지연 시간 등)를 실시간 모니터링하고, 병목 구간을 찾아 쿼리/인덱스/파라미터를 최적화
- 장점: 장애 예방, 성능 유지

 ### 🙋‍♂️ DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?
💁 DB 서버를 분산(샤딩, 리플리케이션 등)하지 않고도 트래픽을 감당하려면 내부 최적화와 자원 활용 극대화가 핵심

1. 인덱스 최적화
- 자주 조회되는 컬럼에 적절한 인덱스를 생성하면 검색 속도가 빨라지고, 전체 시스템 부하가 줄어듬
- WHERE, JOIN, ORDER BY에 자주 쓰이는 컬럼에 인덱스를 적용

2. 쿼리 최적화
- 불필요한 중복 쿼리 제거, 복잡한 쿼리 단순화, 서브쿼리 대신 JOIN 활용 등으로 리소스 소모를 줄임
- 실행 계획(Execution Plan)을 분석해 병목 구간을 찾아 개선

3. 캐싱 활용
- 자주 조회되는 데이터나 쿼리 결과를 메모리 캐시(예: Redis, Memcached)에 저장하면 DB 부하를 크게 줄일 수 있음
- DB 내부 캐시 설정(버퍼 풀, 쿼리 캐시 등)도 적극적으로 활용

4. 서버 설정 튜닝
- DBMS의 메모리 버퍼 크기, 캐시 설정, 연결 수 제한 등 주요 파라미터를 운영 환경에 맞게 조정하면 성능이 크게 향상
- EX) MySQL의 innodb_buffer_pool_size를 늘리면 디스크 I/O가 줄어듬

5. 데이터 분할(파티셔닝)
- 큰 테이블을 파티션으로 나누면 특정 범위의 데이터만 빠르게 조회할 수 있어 성능이 개선

6. 정규화/비정규화 조정
- 과도한 정규화는 JOIN이 많아져 성능 저하를 유발할 수 있다.
- 읽기 성능이 중요하다면 비정규화로 테이블 구조를 단순화할 수 있음.

7. 하드웨어 업그레이드
- CPU, 메모리, 디스크 등 서버 스펙을 높이면 단일 서버에서 더 많은 트래픽을 처리할 수 있음.

8. 연결 풀링 (Connection Pooling)
- 애플리케이션과 DB 사이의 연결을 미리 만들어두고 재사용하면, 동시접속자 증가에도 효율적으로 대응할 수 있음.

