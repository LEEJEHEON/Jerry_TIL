# 인덱스

## 💡인덱스란, 
- 데이터베이스에서 데이터를 더 빠르고 효율적으로 검색할 수 있도록 돕는 자료구조
- 특정 컬럼 또는 컬럼 조합의 값을 정렬된 형태로 보관하며, 이를 통해 효율적으로 데이터를 탐색할 수 있다.

## 💡인덱스와 B-tree
- 인덱스의 구현 방식 중 가장 많이 쓰이는 것이 B-tree
- B-tree는 인덱스를 구성하는 트리 형태의 균형 자료구조로, 빠른 탐색과 삽입, 삭제가 가능

### B-tree
- 이진 트리(Binary Tree)를 확장한 구조로, 한 노드가 2개 이상의 자식 노드를 가질 수 있다.
> 이를 통해 트리 높이를 낮춰서 탐색 성능을 향상시킨다.
- 모든 노드가 균형을 유지하며, 루트 노드에서 리프 노드까지의 길이가 일정하다(균형 트리)
- 각 노드는 키 값과 해당 데이터를 가리키는 포인터를 포함

### B+tree
- B+tree는 내부 노드에는 키만 저장하고 데이터는 리프 노드에만 둔다.
- B+tree의 리프 노드는 연결 리스트로 이어져 있어 범위 검색에 유리하며, 더 많은 키를 한 노드에 담아 캐시 효율성을 높인다.

## 💡인덱스의 장점
- 데이터 검색 속도를 상당히 향상
- 조건 검색(SELECT)은 물론, UPDATE/DELETE의 성능도 함께 향상된다. 왜냐하면 갱신, 삭제 대상도 빠르게 찾을 수 있기 때문
- 정렬이 필요한 경우나 조인 등에서도 성능을 높이는 데 유리

## 💡인덱스의 단점
- 인덱스를 생성하고 유지하기 위해 추가적인 저장 공간이 필요
- 데이터 삽입, 수정, 삭제 작업이 발생할 때마다 인덱스도 갱신되어야 하므로 쓰기 성능은 조금 저하될 수 있다.

## ❓ QnA

### 🙋‍♂️ 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
💁 인덱스는 데이터가 삽입, 수정, 삭제될 때마다 함께 갱신되어야 한다. 따라서 수정이 잦은 테이블에서는 인덱스 갱신 작업이 빈번하게 발생해 추가적인 부하가 생기며, 이로 인해 전체적인 쓰기 작업 성능이 저하
> 인덱스는 조회 성능을 높이나, 자주 변경되는 데이터가 있는 테이블에서는 인덱스 유지 비용 때문에 오히려 성능 저하를 유발할 수 있어 주의가 필요

### 🙋‍♂️ 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
💁 인덱스를 사용하지 않는 컬럼을 조건으로 하는 쿼리는 인덱스 탐색을 하지 않고 전체 테이블을 순차 탐색(Full Table Scan)하게 된다. 이는 인덱스가 없는 필드에 대해 빠른 접근이 불가능하기 때문 
> 인덱스에서 사용하지 않기로 결정한 값이나 컬럼은 데이터베이스에서 인덱스를 활용하지 않고 전체 테이블 스캔이 발생하는 것이 일반적인 운영 정책

### 🙋‍♂️  ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
💁 ORDER BY와 GROUP BY 연산은 데이터 정렬과 그룹핑을 수행하는데, 인덱스의 존재 여부에 따라 동작 방식과 성능에 큰 차이가 있다.
1. 인덱스가 없으면 ORDER BY/GROUP BY 연산은 별도의 정렬 그룹핑 작업이 필요해 비용이 크다.
2. 인덱스가 있으면 이미 정렬된 상태를 활용해 효율적으로 연산할 수 있으며, 성능이 크게 향상된다.
3. ORDER BY/GROUP BY를 자주 사용하는 컬럼에 인덱스를 생성하는 것은 중요한 성능 최적화 전략이다.

### 🙋‍♂️ 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
💁 기본키는 데이터 무결성을 위한 식별자 역할이고, 인덱스는 검색 성능 향상을 위한 구조체이며, 기본키 인덱스는 기본키 제약조건을 만족시키면서 검색을 효율화하기 위해 함께 생성되는 것이라 보면 된다.
> 기본키는 테이블 데이터를 유일하게 식별하는 규칙 또는 제약조건이고, 인덱스는 데이터를 빠르게 검색하기 위한 자료구조이다. 기본키는 보통 인덱스를 포함하지만, 인덱스가 반드시 기본키는 아니다.

### 🙋‍♂️그렇다면 외래키는요?
💁 대부분의 DBMS에서는 외래키에 대해 자동으로 인덱스를 생성하지 않는다. 그러나 외래키 컬럼에 인덱스가 없으면 부모 테이블에서 삭제, 변경 시 자식 테이블의 외래키 값을 검사해야 할 때 전체 테이블 탐색이 발생해 성능 저하가 발생할 수 있다
> 외래키는 다른 테이블의 기본키를 참조하는 제약조건이며, 인덱스는 외래키 컬럼에 대해 자동 생성되지 않으므로 성능 향상을 위해 수동 생성하는 것이 권장

### 🙋‍♂️인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
💁 클러스터드 인덱스가 있으면 인덱스 순서대로 데이터가 물리 저장된다 ( ex)MySQL의 InnoDB )  
클러스터드 인덱스가 없으면 데이터는 인덱스와 별개로 물리적 저장이 이루어지며, 일반적으로 삽입 순서 또는 DBMS가 정한 규칙대로 저장된다.  
넌클러스터드 인덱스는 데이터 순서에는 영향을 미치지 않고, 별도의 인덱스 구조로 빠른 검색만 지원한다

### 🙋‍♂️우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
| 구분        | Redis                                | MongoDB                                  | Hadoop (Hive)                          |
|-------------|------------------------------------|-----------------------------------------|--------------------------------------|
| 인덱스 유형 | 키 기반 단순 인덱스, 일부 자료구조 보조 인덱스 지원 | B-tree/B+tree 계열 복합 인덱스 지원         | 파티셔닝, 버킷, 컬럼스토어 기반 인덱스 (제한적 기능) |
| 저장 매체   | 메모리 중심 (디스크 스냅샷 가능)    | 디스크 기반, 메모리 캐시 활용              | 분산 파일 시스템(HDFS) 기반, 디스크 저장  |
| 주요 용도   | 캐싱, 세션 관리, 실시간 분석 등     | 문서 저장, 복잡한 쿼리, 범위 검색 및 정렬    | 대용량 데이터 분석, 배치 처리             |
| 쿼리 성능   | 매우 빠른 단일 키 조회 중심         | 범위 검색 및 복잡한 쿼리에 효과적            | 대량 데이터 스캔 및 일부 인덱스 최적화 도움  |
| 인덱스 목적 | 빠른 키-값 조회                    | 복잡한 쿼리 성능 향상 및 구조화된 검색       | 파티션/버킷 단위 최적화 및 조인 효율화     |

### 🙋‍♂️ (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
💁 (A, B)와 같이 복합 인덱스가 설정된 테이블에서, 조건에 A가 없고 B 조건만 사용한 쿼리는 일반적으로 인덱스를 제대로 활용하지 못하는 경우가 많다.
- 복합 인덱스는 인덱스가 설정된 컬럼 순서(첫 번째 컬럼부터) 기준으로 검색 최적화를 수행
- 만약 B 조건을 효율적으로 쿼리하려면, (B) 단독 인덱스를 따로 생성하거나, 인덱스 컬럼 순서를 (B, A) 또는 (A, B) 복합 인덱스 여러 개를 만들어서 쿼리 상황에 맞게 인덱스를 타도록 설계
