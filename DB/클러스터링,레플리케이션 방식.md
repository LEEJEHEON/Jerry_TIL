# 클러스터링/레플리케이션 방식

## 💡 클러스터링 
- 클러스터링은 여러 대의 데이터베이스 서버가 하나의 데이터베이스를 함께 관리하는 구조
- 고가용성과 확장성을 위해 사용
- 장애 발생 시 서비스 중단을 최소화하고, 부하 분산을 통해 성능을 높일 수 있음

### 주요 클러스터링 방식
- Active-Active 
    - 모든 서버가 동시에 동작하며 트래픽을 처리
    - 한 서버가 장애를 일으켜도 다른 서버가 바로 역할을 이어받아 무중단 서비스가 가능
    - 부하 분산 효과가 크지만, 스토리지 공유로 인한 병목 현상이 발생할 수 있음
- Active-StandBy (Hot/Cold)
    - 한 서버만 동작(Active)하고, 나머지는 대기(StandBy) 상태
    - Active 서버에 장애가 생기면 StandBy 서버가 Active로 전환되어 서비스를 이어받는다.
    - 비용이 적게 들지만, 장애 발생 시 전환 시간 동안 서비스가 잠시 중단될 수 있음

### 클러스터링의 장점
- 장애 극복(Failover) 시스템 구축
- 부하 분산 및 성능 향상
- 고가용성 확보

## 💡 레플리케이션
- 하나의 데이터베이스를 여러 서버에 복제하여, 데이터의 일관성과 가용성을 높이는 방식
- 주로 읽기 성능 향상, 데이터 백업, 장애 복구에 활용

### 주요 레플리케이션 방식
- Master-Slave(Primary-Replica)
    - 한 서버(Master)가 데이터를 쓰고, 여러 서버(Slave)가 복제본을 읽는다
    - 쓰기 작업은 Master에서만 가능하며, Slave는 읽기 전용
    - 읽기 부하 분산에 효과적
- Master-Master
    - 여러 서버가 동시에 데이터를 쓰고 읽을 수 있음
    - 데이터 동기화가 복잡하지만, 쓰기와 읽기 모두 부하 분산이 가능
- Multi-Master
    - 여러 Master 서버가 서로 데이터를 복제하며, 각 서버에서 쓰기와 읽기가 모두 가능
    - 단, 충돌 관리가 필요

### 레플리케이션의 장점
- 읽기 성능 향상
- 데이터 백업 및 장애 복구
- 지리적으로 분산된 서비스 지원 

## 💡 샤딩(Sharding)
- 확장성(Scalability)과 성능 향상이 목적
- 데이터 전체를 여러 서버(샤드)에 분산 저장하여, 각 서버가 일부 데이터만 담당하게 만듬
- 대용량 데이터 처리, 트래픽 분산에 효과적

### 샤딩 vs 레플리케이션/클러스터링링

| 구분        | 샤딩                                   | 레플리케이션/클러스터링                    |
|-------------|------------------------------------|-----------------------------------------|
| 데이터 분포 | 각 샤드가 일부 데이터만 저장 | 모든 노드가 동일한 데이터 저장       |
| 확장성   | 서버 추가 시 데이터 분산, 확장 용이  | 서버 추가 시 데이터 복제, 확장성은 제한적 |
| 장애 허용   |	샤드 장애 시 해당 데이터만 접근 불가 | 한 노드 장애 시 다른 노드가 대체 가능 |
| 일관성   |	일관성 유지가 어려울 수 있음 | 높은 일관성 유지 |
| 복잡성	 | 샤드 키 설계, 데이터 분산 등 복잡 |  상대적으로 단순 |

### 언제 어떤 방식을 선택해야 하는지
- 샤딩 
    - 데이터가 매우 많아 한 서버에 모두 저장/처리하기 어려울 때
    - 트래픽이 특정 데이터에 집중되어 병목이 발생할 때
    - 확장성과 성능이 최우선일 때 (예: 대규모 사용자 서비스, SNS, 로그 저장 등)
    - 단, 샤드 키 설계와 데이터 분산, 장애 복구가 복잡하므로 운영 난이도가 높음

- 레플리케이션/클러스터링
    - 서비스의 고가용성과 장애 복구가 중요할 때
    - 읽기 부하가 많고, 데이터 일관성이 중요한 서비스 (예: 금융, ERP 등)
    - 데이터 양이 서버 한 대에 충분히 저장/처리 가능한 경우
    - 운영이 상대적으로 단순하고, 장애 시 빠른 복구가 필요할 때

## 💡 확장성 및 성능

### 읽기/쓰기 부하 분산 전략
- 레플리케이션 
    - 일반적으로 "Master-Slave" 구조를 사용
    - 쓰기 연산은 Master(Source) 서버에서만 처리하고, 읽기 연산은 여러 Replica(Slave) 서버에서 분산 처리
    - 대부분의 서비스에서 읽기 요청이 쓰기보다 훨씬 많으므로, Replica 서버를 여러 대 두어 읽기 부하를 효과적으로 분산
    - 장애 발생 시 Replica를 Master로 승격하여 서비스 연속성을 확보할 수 있음 

- 클러스터링
    - 여러 DB 서버가 하나의 논리적 단위로 묶여, 동시에 트래픽을 처리
    - Active-Active 방식: 모든 서버가 읽기/쓰기를 동시에 처리하여 부하를 분산
    - Active-Standby 방식: 한 서버만 동작하고, 나머지는 대기하다가 장애 시 전환
    - 클러스터링은 서버 간 동기화와 장애 복구에 강점이 있지만, 스토리지 공유 구조에서는 병목이 발생할 수 있음음

### 클러스터링과 레플리케이션의 확장 한계와 병목
- 레플리케이션의 확장 한계
    - 읽기 성능은 Replica 서버를 추가함으로써 수평적으로 확장(Scale Out)할 수 있음
    - 하지만 쓰기 성능은 Master 서버 하나에 집중되므로, 쓰기 부하가 많아지면 병목이 발생
    - 데이터 동기화 지연(Replication Lag)이나 장애 시 데이터 일관성 문제가 생길 수 있음 

- 클러스터링의 확장 한계
    - Active-Active 구조에서는 여러 서버가 동시에 작업하지만, 공유 스토리지(Shared-Everything) 구조에서는 스토리지가 병목 지점이 될 수 있음 
    - 서버를 추가해도 스토리지의 처리 능력이 한계에 도달하면 전체 성능이 저하됨
    - 동시성 제어, 데이터 충돌, 복잡한 동기화가 필요해 관리가 어려워질 수 있음 

## 💡구현 기술별 차이

> 주요 DBMS의 클러스터링/레플리케이션 방식 비교

### 1. MySQL 
- 클러스터링/레플리케이션 방식
    - Master-Slave(Primary-Replica) 복제: 가장 널리 사용되는 방식. Master에서 쓰기, Slave에서 읽기 분산.
    - Group Replication/InnoDB Cluster: 여러 노드가 동시에 읽기/쓰기를 처리하는 고가용성 클러스터링. 자동 장애 복구 지원.
    - MySQL NDB Cluster: 고성능 트랜잭션 환경에 적합한 분산 클러스터. 데이터와 노드가 분리되어 수평 확장에 유리함.

- 설정 방법
    - CHANGE MASTER TO, START SLAVE 명령으로 복제 설정.
    - InnoDB Cluster는 MySQL Shell을 통해 손쉽게 구성 가능.
    - NDB Cluster는 별도의 관리 노드와 데이터 노드 설정 필요.

- 관리 도구
    - MySQL Workbench: GUI 기반 관리 및 모니터링.
    - MySQL Shell: 클러스터 관리, 복제 설정.
    - Percona Toolkit: 고급 관리 및 모니터링.

- 모니터링 방법
    - SHOW SLAVE STATUS, SHOW MASTER STATUS로 복제 상태 확인.
    - Performance Schema, MySQL Enterprise Monitor 등 활용.

### 2. Postgre SQL 
- 클러스터링/레플리케이션 방식
    - Streaming Replication: WAL(Write-Ahead Log)을 실시간으로 복제. 동기/비동기 모두 지원.
    - Logical Replication: 테이블 단위로 데이터 복제. 데이터 변환, 필터링 가능.
    - Patroni, Citus: 고가용성 클러스터링 및 샤딩 확장 솔루션.

- 설정 방법
    - primary_conninfo 파라미터로 복제 노드 연결.
    - pg_basebackup으로 초기 데이터 복제.
    - CREATE PUBLICATION, CREATE SUBSCRIPTION으로 논리적 복제 설정.

- 관리 도구
    - pgAdmin: GUI 기반 관리 및 모니터링.
    - Patroni: 자동 장애 복구, 클러스터 관리.
    - Citus: 샤딩 및 분산 처리 지원.

- 모니터링 방법
    - pg_stat_replication 뷰로 복제 상태 확인.
    - Prometheus + Grafana: 성능 및 상태 모니터링.

### 3. Oracle
- 클러스터링/레플리케이션 방식
    - Oracle RAC(Real Application Clusters): 여러 노드가 하나의 데이터베이스를 공유하며, Active-Active 구조로 고가용성/부하 분산 지원.
    - Data Guard: 물리적/논리적 복제, 장애 복구 및 재해 복구에 특화.
    - GoldenGate: 실시간 데이터 복제 및 동기화 솔루션.

- 설정 방법
    - RAC: Grid Infrastructure 설치, ASM(Automatic Storage Management) 구성 필요.
    - Data Guard: DGMGRL 유틸리티로 복제 설정
    - GoldenGate: 별도 소프트웨어 설치 및 구성

- 관리 도구
    - Oracle Enterprise Manager: 통합 관리 및 모니터링.
    - DGMGRL: Data Guard 관리.
    - SRVCTL: RAC 클러스터 관리.

- 모니터링 방법
    - Enterprise Manager에서 클러스터, 복제, 장애 상태 실시간 모니터링.
    - V$ 뷰, Data Guard Broker 등 활용.

### 핵심 포인트
- MySQL은 손쉬운 복제와 다양한 클러스터링 옵션, 저렴한 구축 비용이 강점.
- PostgreSQL은 고급 복제, 샤딩, 확장성, 커뮤니티 지원이 뛰어남.
- Oracle은 엔터프라이즈 환경에 최적화된 고가용성, 강력한 클러스터링과 복제, 통합 관리 도구가 특징.

## ❓ QnA

### 🙋‍♂️ 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
💁 분산 DB 환경에서는 여러 노드나 서비스에 데이터가 분산되어 있기 때문에, 트랜잭션의 원자성(Atomicity)과 일관성(Consistency)을 보장하는 것이 단일 DB보다 훨씬 복잡

1. 2-Phase Commit (2PC)
- 2PC는 트랜잭션 조정자(Coordinator)가 여러 노드에 트랜잭션을 요청하고, 모든 노드가 준비(Prepare)되면 최종적으로 커밋(Commit) 또는 롤백(Rollback)을 결정하는 방식
- 단계: 
    - Prepare Phase: 각 노드에 트랜잭션 실행 가능 여부를 묻고, 잠금(Lock)을 설정
    - Commit Phase: 모든 노드가 준비되었다고 응답하면, Coordinator가 커밋 또는 롤백을 지시
- 장점: 원자성 보장, 일관성 유지.
- 단점: 네트워크 장애나 노드 장애 시 블로킹(Blocking) 문제가 발생할 수 있고, 성능 저하가 있을 수 있음

2. Saga 패턴
- 트랜잭션을 여러 개의 작은 로컬 트랜잭션으로 나누고, 각 단계가 성공하면 다음 단계로 진행
- 실패 시에는 보상 트랜잭션(Compensation Transaction)으로 이전 상태를 복구
- 장점: 비동기 처리, 장애 복구가 용이, 블로킹 문제 없음.
- 단점: 데이터 일관성 보장이 약해질 수 있고, 보상 트랜잭션 설계가 복잡

3. 기타 전략
- CDC(Change Data Capture), 트랜잭셔널 아웃박스 등 이벤트 기반 데이터 동기화 방식도 활용
- 분산 컨센서스 프로토콜(예: Paxos, Raft)로 트랜잭션 커밋 여부를 다수결로 결정하는 방식도 있음

<실무에서의 선택 기준>
- 단일 DB 내 트랜잭션: 일반적인 ACID 트랜잭션 사용.
- 분산 환경: 2PC는 강한 일관성이 필요할 때, Saga는 비동기 처리와 장애 복구가 중요할 때 적합.

### 🙋‍♂️ 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
💁 Master-Slave 구조에서 데이터가 완전히 동기화되기 전까지 정합성(Consistency)을 지키는 것은 쉽지 않은 과제
1. 동기/반동기(Semi-Sync) 복제 방식 활용
- 비동기 복제는 Master에서 커밋된 데이터가 Slave에 바로 반영되지 않아, 일시적으로 데이터 불일치가 발생할 수 있음
- 반동기(Semi-Sync) 복제는 Master가 최소 1대 이상의 Slave가 변경 로그(릴레이 로그)를 수신할 때까지 커밋을 대기
    - 이 방식은 완벽한 동기화는 아니지만, 데이터 손실 위험을 줄이고 정합성을 어느 정도 보장
- MySQL/MariaDB에서는 rpl_semi_sync_master_enabled 설정으로 Semi-Sync 복제를 활성화할 수 있음

2. Master에서만 쓰기, Slave는 읽기 전용
- 쓰기 작업은 반드시 Master에서만 처리하고, Slave에서는 읽기만 허용
- Slave의 데이터가 완전히 동기화되기 전까지 쓰기 작업으로 인한 데이터 불일치 문제를 예방할 수 있음 
- 데이터 정합성이 중요한 서비스(예: 금융, 결제)는 반드시 Master에서 조회하도록 설계

3. 애플리케이션 레벨에서 분기 처리
- 애플리케이션에서 중요한 데이터 조회는 Master에서 직접 읽도록 분기
- Slave의 데이터가 최신 상태가 아닐 수 있으므로, 실시간성이 필요한 경우 Master를 우선 사용
- 화면 새로고침, 재조회 등으로 데이터 갱신을 유도할 수도 있음

4. 장애 복구 시 최신 Slave 선택
- 장애 발생 시, Slave 중 가장 최신 데이터(복제 지연이 가장 적은 노드)를 Master로 승격하여 데이터 손실을 최소화
- 복제 로그(binlog)와 relay log의 포지션을 비교하여, 최대한 동기화된 Slave를 선택

5. 자동증가(AUTO_INCREMENT) 값 충돌 방지
- Master-Master 구조에서는 auto-increment-increment와 auto-increment-offset 설정으로 각 서버의 자동 증가 값을 다르게 하여, 데이터 충돌을 방지

6. 데이터 정합성 트레이드오프 인식
- 비동기 복제 환경에서는 일시적인 데이터 불일치가 불가피할 수 있다. 
- 서비스의 안정성과 고가용성이 더 중요하다면, 약간의 불일치를 감수하는 것이 현실적인 선택


### 🙋‍♂️ 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
💁 Deadlock은 아래 4가지 조건이 모두 성립할 때 발생

1. 상호 배제(Mutual Exclusion): 한 번에 하나의 트랜잭션만 자원을 사용할 수 있음
2. 점유와 대기(Hold and Wait): 자원을 점유한 채 다른 자원을 기다림
3. 비선점(No Preemption): 자원을 강제로 빼앗을 수 없음
4. 환형 대기(Circular Wait): 트랜잭션들이 원형으로 자원을 서로 기다림

Deadlock 해결 방법

1. 예방(Prevention)
- 자원 할당 순서 고정: 모든 트랜잭션이 자원을 정해진 순서대로만 요청하게 하여 환형 대기를 방지
- 필요한 모든 자원 선점: 트랜잭션 시작 시 필요한 모든 자원을 한 번에 할당받게 하여 점유와 대기를 막는다.

2. 회피(Avoidance)
- 타임스탬프 기반 회피: Wait-Die, Wound-Wait 등 시간 정보를 활용해 데드락이 발생하지 않도록 자원 할당을 조정

3. 감지 및 복구(Detection & Recovery)
- 자동 데드락 감지: DBMS가 트랜잭션 대기 그래프를 분석해 데드락을 감지하면, 진행 상태가 가장 낮은 트랜잭션을 자동 롤백하여 교착 상태를 해소
- 타임아웃 설정: 일정 시간 동안 락을 획득하지 못하면 트랜잭션을 강제로 중단시켜 데드락을 해소

4. 쿼리/로직 개선
- 데이터 접근 순서 통일: 여러 트랜잭션이 동일한 순서로 자원을 접근하도록 설계하면 데드락 발생 확률이 크게 줄어듬
- 작업 단위 최소화: 한 트랜잭션에서 너무 많은 작업을 처리하지 않도록 쿼리와 로직을 분리
- 인덱스 활용: WHERE 조건에 인덱스를 걸어 불필요한 락 범위를 줄인다.
- Queue 처리: 트래픽이 몰릴 때는 작업을 큐에 쌓아 순차적으로 처리

5. 분산락/외부 락 활용
- 분산락(예: Redis, 네임드 락): DB 외부에서 락을 관리해 동시성 문제와 데드락을 예방할 수있음 

### 🙋‍♂️ 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
💁 분산 환경에서 DB를 관리해야 한다면 레플리케이션과 샤딩은 목적과 효과가 다르기 때문에, 서비스의 요구사항에 따라 선택이 달라진다.

레플리케이션
- 적합한 상황:
    - 데이터 양이 한 서버에 충분히 저장 가능할 때
    - 읽기 트래픽이 많고, 데이터 일관성이 중요할 때
    - 장애 복구와 고가용성이 중요한 서비스
- 한계:
    - 쓰기 성능은 Master에 집중되어 확장에 한계가 있음
    - 데이터가 매우 많아지면 Master의 성능이 병목이 됨

샤딩
- 적합한 상황:
    - 데이터가 너무 많아 한 서버에 저장/처리 불가할 때
    - 쓰기/읽기 트래픽이 모두 많고, 서버 확장이 필요한 대규모 서비스
    - 병렬 처리와 트래픽 분산이 중요한 경우
- 한계:
    - 샤드 키 설계, 데이터 분산, 장애 복구가 복잡함
    - 전체 데이터에 대한 조인, 집계 쿼리가 어려워질 수 있음
<br><br>

결론: 어떤 방식을 선택할까?
- 읽기 부하 분산, 고가용성, 장애 복구가 중요하고 데이터 양이 한 서버에 감당 가능한 수준이면 레플리케이션이 적합합니다.
- 데이터가 매우 많거나, 쓰기/읽기 모두 확장성이 필요하다면 샤딩이 필요합니다.
- <b>실제로는 샤딩과 레플리케이션을 함께 사용하는 경우도 많습니다.</b> 예를 들어, 샤딩으로 데이터를 분산하고, 각 샤드 그룹에 레플리케이션을 적용해 고가용성과 확장성을 동시에 확보할 수 있다. 