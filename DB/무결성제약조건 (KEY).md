# 무결성졔약조건 (KEY)

## Key (기본키, 후보키, 슈퍼키 등등...)

### 💡 슈퍼키 
- 하나 또는 여러 컬럼들의 집합으로, 테이블 내 모든 데이터들을을 유일하게 식별해주는 키
- 유일성은 보장하지만, 최소성은 보장하지 않음 (1개 테이블의 여러개의 슈퍼키가 존재할 수 있음)

### 💡후보키
- 슈퍼키에서 최소성까지 만족하는 키
- 유일성과 최소성을 동시에 보장 (1개 테이블의 여러 후보키 존재할 수 있음 )

### 💡 기본키
- 후보키중 하나를 선정하여 대표로 삼는 키
- NULL 불가능, 중복값 X
- 기본키 제약조건을 토해 개체 무결성 보장

### 💡 대체키
- 후보키 중에서 기본키로 선정되지 않은 나머지 키

### 💡 외래키
- 다른 테이블의 기본키를 참조하는 키 
- 테이블 간의 관계를 표현함 
- 참조하는 키값(기본키)이 테이블에 존재해야 하며, 부모 테이블에 데이터가 있어야 자식 테이블도 데이터 입력이 가능함
- 또한, 삭제도 부모 테이블의 삭제 규칙에 따라서 자식 테이블의 데이터 삭제 또는 갱신도 제어됨  

※ 삭제 규칙  
| 규칙         | 설명                                                         | 동작 예시                           |
|--------------|------------------------------------------------------------|----------------------------------|
| CASCADE      | 부모 행이 삭제되면 자식 테이블의 참조하는 모든 행도 함께 삭제됨 | 부모 행 삭제 시 자식 행 모두 삭제 |
| SET NULL     | 부모 행이 삭제되면 자식 테이블의 외래키 컬럼 값이 NULL로 변경됨 | 부모 행 삭제 시 자식 외래키 NULL  |
| RESTRICT     | 자식 테이블에 참조 중인 행이 있으면 부모 행 삭제가 거부됨       | 자식 레코드 존재 시 부모 삭제 불가 |
| NO ACTION    | RESTRICT와 유사하며 기본값. 자식 레코드 존재 시 부모 삭제 불가   | 자식 레코드 존재 시 부모 삭제 불가 |
| SET DEFAULT  | 부모 행 삭제 시 자식 외래키 컬럼이 기본값으로 설정됨            | 부모 행 삭제 시 자식 외래키 기본값 설정 |


### 💡 복합키
- 둘 이상의 컬럼을 조합하여 만든 키
- 딘일 컬럼만으로 유일성이 보장할 수 없을 때 사용


| 키 종류   | 유일성 | 최소성 | NULL 허용 | 복수 가능 | 특징 및 설명 |
|-----------|-------|--------|-----------|-----------|-------------|
| 슈퍼키    | O     | X      | O         | O         | 유일성을 가진 속성 또는 속성들의 집합. 불필요한 속성 포함 가능. |
| 후보키    | O     | O      | O         | O         | 슈퍼키 중 최소성을 만족하는 키. 유일성과 최소성을 모두 가짐. |
| 기본키    | O     | O      | X         | X         | 후보키 중 하나를 대표로 선택. NULL 값과 중복 불가. |
| 대체키    | O     | O      | O         | O         | 후보키이지만 기본키로 선택되지 않은 키. |
| 외래키    | 부분 가능 | X      | 가능      | O         | 다른 테이블 기본키를 참조하는 키. 참조 무결성 유지에 사용. |
| 복합키    | O     | O      | NULL 컬럼 없으면 불가 | O | 두 개 이상의 컬럼을 조합해 만든 키. 단일 컬럼으로 유일성 확보 불가 시 사용. |

--- 
## 👍 키 선택 시 고려사항
- 비즈니스 관점에서 영속성 있게 유지될 수 있는 속성 선택해야함
- 변경 가능성이 적고, 값이 중복되지 않는 속성
- 키가 너무 많거나 크면 성능 저하 요인이 될 수 있으므로 최소성 유지해야함 


## ❓ QnA

### 🙋‍♂️ 기본키는 수정이 가능한가요?
💁 원칙적으로는 수정하지 않는 것을 권장. 왜냐면 해당 값이 변경되면 데이터 무결성과 참조 무결성에 영향을 줄 수 있기에<br>
하지만, 기술적으로는 수정이 가능하다
-  수정조건 1
    > 수정하려는 값이 기존에 없는 새로운 값(유일성 보장)
-  수정조건 2
    > 수정하려는 값이 null이 아닐 것
- 수정조건 3 
    > 해당 기본키를 참조하는 외래키가 없거나, 외래키의 제약조건이 on update cascade 인 경우 (연쇄 갱신)  

### 🙋‍♂️  사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
💁 MySQL은 기본키 설정이 필수 조건이 아니라서 기본키 없이 테이블 생성이 가능함 <br>


### 🙋‍♂️  외래키 값은 NULL이 들어올 수 있나요?
💁 참조하는 값이 없음을 나타내기 위해 NULL 값을 허용하는 경우가 많음 <br>
예를 들어, 자식 테이블이 아직 부모 레코드를 참조하지 않는 선택적 관계 (옵셔널 관계)를 표현할 때 유리 <br>
외래키 제약 조건에 set null을 하면 부모 테이블의 기본키 값이 삭제될 때, 해당 값은 null으로 자동 변경


### 🙋‍♂️  어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
💁 UNIQUE 키워드를 부여하면 자동으로 UNIQUE INDEX가 생성된다. <br>
즉, UNIQUE 인덱스를 가진 컬럼을 조회(SELECT)할 때 <U>성능은 개선</U>됨. <br>
하지만, INSERT/DELETE 작업 시, 중복 체크 과정이 필요하여 <U>성능저하</U> 발생

### 🙋‍♂️  기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
💁 기본키는 유일하고 NULL 불가한 컬럼에 부여하는 제약조건이며, 이 제약을 효율적으로 구현하기 위해 DBMS가 자동으로 인덱스를 생성함. (즉, 기본키는 인덱스스)
 <br>
차이점

| 구분       | 기본키 (Primary Key)                             | 인덱스 (Index)                               |
|------------|-------------------------------------------------|----------------------------------------------|
| 개념       | 테이블의 각 행을 **유일하게 식별**하는 속성 또는 속성들의 집합 (논리적 제약조건) | 테이블 내 데이터를 빠르게 찾기 위한 **물리적 자료구조** |
| 고유성     | 반드시 유일한 값이어야 하며, NULL 값 허용하지 않음 | 고유 인덱스는 중복 불가, 일반 인덱스는 중복 허용 가능       |
| 자동 생성  | 기본키로 지정하면 DBMS가 **자동으로 유니크 인덱스 생성 및 관리**         | 사용자가 명시적으로 생성. 기본키가 있으면 기본키가 클러스터형 인덱스 역할을 함 |
| 클러스터링 | (MySQL InnoDB 등) 기본키는 **클러스터형 인덱스**로, 데이터 레코드가 인덱스에 포함됨 | 일반 인덱스는 **보조 인덱스**로, 리프 노드에 기본키 값을 저장해 기본키 인덱스를 참조함 |
| 역할       | 데이터 무결성 보장 및 고유 식별자 역할                  | 데이터 검색 성능 향상                              |



####  🙋‍♂️  그렇다면 외래키는요?
💁 외래키는 참조 무결성 및 관계 설정을 위해 존재하며, 반드시 인덱스를 가지는 것은 아니지만, 성능을 위해 추가하는 것이 좋다.