# 트랜잭션

## 💡트랜잭션이란,
- DBMS에서 데이터를 다루는 논리적인 작업의 단위
> 트랜잭션을 정의하는 이유
>> 1. 데이터를 다룰 때 장애가 일어나면, 트랜잭션은 장애 시 데이터를 복구하는 작업의 단위가 됨
>> 2. DB에서 여러 작업이 동시에 같은 데이터를 다룰 때, 트랜잭션은 이 작업을 서로 분리하는 단위가 됨 

## 💡트랜잭션의 성질 (ACID 원칙)
- ACID 원칙은 데이터베이스 시스템의 무결성, 신뢰성, 안정성을 확보하는데 매우 중요한 역할

1. Atomicity (원자성)
- 트랜잭션 내 여러 작업이 모두 수행되거나 전혀 수행되지 않아야 한다는 성질 (ALL or nothing)
- 부분 완료가 불가능하며, 오류 발생 시 전체 트랜잭션이 무효화
(SAVEPOINT : 에러가 발생하면 트랜잭션 전체가 ROLLBACK이 아니라 SAVEPOINT로 되돌아간다.)
  
2. Consistency (일관성)
- 트랜잭션이 실행되기 전과 후에 데이터베이스의 규칙, 제약조건이 항상 맞아떨어져야 한다는 성질
- 트랜잭션 실행 전후에 항상 데이터의 무결성이 보장되어야 한다.
  
3. Isolation (고립성)
- 동시에 여러 트랜잭션이 실행되어도 각각의 트랜잭션이 서로 간섭받지 않아야 한다는 성질
- 고립성을 유지하기 위해서는 변경중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰려고 할 때 제어하는 작업이 필요
  
4. Durability (지속성)
- 트랜잭션이 성공적으로 완료(커밋)되면, 해당 결과는 DB에 영구적으로 반영되어야 한다는 성질
- 예기치 못한 시스템 장애나 오류가 발생해도 트랜잭션의 결과는 보존
  
## 💡동시성 제어
- 다수의 트랜잭션이 동시에 데이터베이스에 접근할 때 데이터의 일관성, 무결성을 유지하고 성능을 보장하기 위한 핵심 기법

※ 트랜잭션의 읽기 / 쓰기 시나리오오
| 상황   | 트랜잭션1 | 트랜잭션2 | 발생 문제 | 동시 접근 |
|-----------|-------|--------|-----------|-----------|
| 상황 1    | 읽기  | 읽기 | 없음         | 허용         |
| 상황 2    | 읽기  | 쓰기 | 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 | 허용 혹은 불가 선택 |
| 상황 3    | 쓰기  | 쓰기 | 갱신손실       | 허용불가(LOCK을 이용) |

### 갱신손실
- 2개의 트랜잭션이 1개의 데이터를 동시에 갱신할 때 발생 (절대 발생하면 안되는 현상)

### 동시성 제어의 주요 목적
- 트랜잭션 간 상호 간섭 최소화
- 데이터 일관성 및 무결성 유지
- 시스템 성능 (처리량, 응답시간) 극대화
- 직렬화 (Serializability) 보장 : 결과가 마치 트랜잭션을 순차적으로 수행한 것과 동일해야 함

## 💡락
- 데이터베이스에서 여러 트랜잭션이 동시에 동일한 데이터에 접근할 때 데이터의 일관성을 보장하고 충돌을 방지하기 위해 사용되는 동시성 제어 기술
- 특정 데이터(행, 테이블 등)에 대해 하나의 트랜잭션이 작업을 완료할 때까지 다른 트랜잭션의 접근을 제한

### 락의 종류
1. 공유락 (Shared Lock)
- 읽기 작업에 사용. 여러 트랜잭션이 동시 읽기는 가능하지만, 쓰기는 제한

2. 배타락 (Exclusive Lock)
- 쓰기 작업에 사용. 한 트랜잭션만 접근 가능하며, 읽기/쓰기 모두 제한

### 데드락 (Deadlock)
- 둘 이상의 트랜잭션이 서로의 락을 기다려 무한 대기
- 보통 데드락이 발생하면 DBMS는 데드락이 걸린 트랜잭션 중 하나를 강제로 중지시켜 정상화 한다.

## 💡트랜잭션 고립 수준 (격리 수준, Isolation Level)
- 여러 트랜잭션이 동시에 진행될 때, 특정 트랜잭션이 다른 트랜잭션의 데이터 변경을 어느 정도까지 볼 수 있게 허용할지 결정하는 기준

### 트랜잭션 동시 실행 문제
1. 오손 읽기 (Dirty Read) : 커밋되지 않은 데이터(다른 트랜잭션에서 변경했으나 아직 확정되지 않은 값)를 읽음
2. 반복 불가능 읽기 (Non-repeatable Read) : 한 트랜잭션 내에서 같은 데이터를 두 번 읽을 때 각각의 값이 다름 (중간에 값이 변경됨)
3. 유령데이터 읽기 (Phantom Read) : 한 트랜잭션 내에서 같은 쿼리를 두 번 실행하는 사이에 새로운 데이터가 추가되어 결과가 달라짐

### 트랜잭션 고립 수준 종류
| 고립 수준           | 특징                                                        | Dirty Read | Non-Repeatable Read | Phantom Read |
|---------------------|-----------------------------------------------------------|:----------:|:-------------------:|:------------:|
| READ UNCOMMITTED    | 가장 낮은 수준, 커밋 전 변경 데이터도 읽을 수 있음             |     O      |          O          |      O       |
| READ COMMITTED      | 커밋된 데이터만 접근, 대부분 DBMS 기본값                     |     X      |          O          |      O       |
| REPEATABLE READ     | 트랜잭션 내 동일 데이터 반복 조회 가능, 다른 트랜잭션의 수정/삭제 불가 |     X      |          X          |      O       |
| SERIALIZABLE        | 가장 높은 수준, 모든 읽기/쓰기가 직렬로 실행됨                 |     X      |          X          |      X       |

### 정리
- 고립 수준이 높을수록 데이터 정합성이 강화되고 동시성은 떨어집니다.
- 일반적으로 Read Committed나 Repeatable Read가 많이 사용
- 완벽한 데이터 일관성이 필요한 경우는 Serializable을 사용하지만, 성능에 큰 영향을 줄 수 있습니다.

## 💡회복
- 데이터베이스에서 장애(전원 오류, 시스템 고장, 소프트웨어 버그 등)가 발생했을 때, 손상된 데이터를 장애 발생 이전의 일관되고 안정적인 상태로 되돌리는 과정

### 회복 기법의 종류
| 회복 기법          | 설명                                                                                     | 특징 및 장단점                                          |
|-------------------|-----------------------------------------------------------------------------------------|-------------------------------------------------------|
| 지연 갱신 회복 기법 (Deferred Update) | 트랜잭션이 완료될 때까지 변경 내용을 로그에만 저장하고, DB에는 반영을 지연하는 방식               | Undo 불필요, 복구 간단, 즉시 최신 데이터 조회 불가             |
| 즉시 갱신 회복 기법 (Immediate Update) | 변경 사항을 트랜잭션 수행 중 바로 DB에 반영하고 로그에도 기록                                   | Undo/Redo 필요, 즉시 최신 데이터 조회 가능, 복구 복잡          |
| 체크포인트 회복 기법 (Checkpoint Recovery) | 일정 주기로 검사점(Checkpoint)을 찍어 로그 처리 범위를 제한해 장애 시 빠른 복구 가능                | 빠른 복구 가능, 주기적 관리 필요                            |
| 그림자 페이징 회복 기법 (Shadow Paging) | 트랜잭션 동안 변경 내용은 그림자 페이지에 저장, 완료 시 교체, 실패 시 폐기                           | Undo 불필요, 페이지 관리 복잡, 성능 저하 가능성               |
| 미디어 회복 기법 (Media Recovery)       | 디스크 등 저장장치 장애시 백업(덤프) 데이터를 이용해 복구                                         | 하드웨어 장애 대비, 복구 시간 백업 주기에 따라 다름            |


## ❓ QnA

### 🙋‍♂️ ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
💁 로그 기록과 체크포인트를 활용하여 데이터의 변경 내역을 안전하게 관리하고, 트랜잭션 커밋 시 이를 디스크에 영구 저장함으로써 Durability를 보장합니다.

### 🙋‍♂️ 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
💁 인도네시아 프로젝트 당시에 민감한 자금 데이터를 다룰 때, 사용했었습니다. 한 사이클에 모든 데이터가 이관이 되면 COMMIT이 되도록 LAST COMMIT 방식으로 하였고, 에러나 데이터 이관량이 불일치할 시 전체를 ROLLBACK를 했었습니다. 

### 🙋‍♂️ 읽기에는 트랜잭션을 걸지 않아도 될까요?
💁단순한 읽기 작업만 수행할 때는 반드시 트랜잭션으로 묶지 않아도 되지만, 동시성 문제나 데이터 일관성 보장을 원한다면 읽기 작업에도 트랜잭션을 걸어야 합니다.  
다만 읽기 작업에 불필요하게 오래 트랜잭션을 유지하면 성능 저하(Undo 로그 증가, 락 경쟁 등)를 초래할 수 있으므로 필요에 따라 최소한으로 사용하는 것이 권장됩니다

### 🙋‍♂️ 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
💁 
1. 성능과 동시성 고려  
고립 수준이 높아질수록 데이터 일관성은 강화되지만, 동시성은 떨어지고 시스템 성능 저하가 발생합니다. 결국 DBMS마다 성능과 일관성 간 균형을 다르게 설계합니다.
  
2. 실제 업무 환경 적합성  
대부분의 어플리케이션에서는 최고 수준인 Serializable까지 엄격하게 적용할 필요가 없으며, 그 대신 적절한 성능과 일관성을 지원하는 일부 고립 수준만 제공하는 경우가 많습니다.

3. 구현 복잡도와 비용  
모든 고립 수준을 완벽 구현하려면 내부적으로 복잡한 락 관리, 버전 관리, 병행제어 기법 등이 필요해 개발과 유지보수 비용이 증가합니다.

4. 표준과 차이  
SQL 표준에서는 4가지 고립 수준을 명시하지만, 실제로는 DBMS마다 일부 수준만을 지원하거나 이름과 동작이 다소 다릅니다. 예를 들어, MySQL InnoDB는 기본값이 Repeatable Read지만 Read Uncommitted는 지원하지 않고, Oracle은 Read Uncommitted를 지원하지 않습니다.

### 🙋‍♂️ 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
💁 
1. Undo 영역  
- 트랜잭션이 데이터를 변경(UPDATE, DELETE 등)하기 전에 변경 전의 데이터를 저장하는 영역입니다
- 주로 트랜잭션 롤백 시 변경 전 상태로 되돌리기 위해 사용되며, MVCC(다중 버전 동시성 제어)를 위한 이전 버전 데이터 유지에도 활용됩니다.
- Undo 로그는 트랜잭션 종료 시까지 유지되며, 변경된 컬럼의 이전 값만 저장해 효율적으로 관리됩니다.
- Undo 로그는 Undo 테이블스페이스의 롤백 세그먼트에 저장되어 트랜잭션 별로 할당됩니다.

2. Redo 영역
- 트랜잭션의 변경 내용을 디스크에 반영하기 전에 로그 파일에 먼저 기록하는 영역입니다.
- 시스템 장애 발생 시, 로그를 사용해 커밋된 트랜잭션의 작업을 재실행(Redo)하여 데이터베이스를 일관된 상태로 복구합니다.
- Write-Ahead Logging(WAL) 원칙에 따라 실제 데이터파일보다 먼저 Redo 로그가 기록되며, 메모리 내 로그 버퍼 후에 순환 로그 파일(ib_logfile0, ib_logfile1)에 저장됩니다.
- Redo 로그는 LSN(Log Sequence Number)로 관리되고, 장애 복구와 버퍼 풀 관리에 필수적입니다.

### 🙋‍♂️ 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
💁 데이터베이스 관리 시스템(DBMS)에서 실제 데이터가 저장되고 관리되는 방식을 담당하는 핵심 구성 요소
- DBMS 내에서 데이터를 실제로 저장하고 읽어오며, 트랜잭션, 잠금, 인덱싱, 복구 등의 핵심 기능을 처리합니다.
- MySQL 같은 경우 대표적으로 InnoDB(트랜잭션 및 ACID 지원)와 MyISAM(비트랜잭션, 빠른 읽기) 등이 있습니다.
- 사용자는 테이블 생성 시 엔진을 지정하여 요구사항에 맞는 성능과 기능을 선택할 수 있습니다
