# DB Locking

## 💡DB Locking이란,
- Lock(잠금)은 데이터베이스의 특정 자원(테이블, 행 등)에 대해 하나의 트랜잭션만 접근하도록 제한함으로써 데이터의 일관성과 무결성을 보호
- 트랜잭션이 데이터를 수정할 때 Lock을 획득하고, 다른 트랜잭션은 해당 데이터에 접근(읽기/쓰기)이 제한
- Lock은 트랜잭션의 시작과 끝(커밋/롤백) 시점에 설정 및 해제

## 💡Lock의 종류
1. 공유 락(Shared Lock, S-Lock): 데이터를 읽기 위한 락으로, 여러 트랜잭션이 동시에 읽을 수 있지만, 쓰기(수정)는 불가능
2. 배타 락(Exclusive Lock, X-Lock): 데이터를 읽기 및 쓰기 위한 락으로, 한 트랜잭션이 점유 시 다른 트랜잭션의 접근(읽기/쓰기) 모두 차단
3. 락의 단위는 데이터베이스, 테이블, 행 등 다양하게 설정할 수 있습니다. 범위가 좁을수록 동시성은 높아지고, 넓을수록 단순하지만 동시 접근이 제한

## 💡Locking 방식의 특징
- Locking을 통해 트랜잭션 간의 병행 실행 중 발생 가능한 경합, 일관성 문제, 무결성 위반을 방지할 수 있다.
- 2단계 잠금 프로토콜(2PL Protocol): 락 획득과 해제로 나누어진 두 단계로 관리되며, 일관성 유지는 쉽지만 교착 상태(Deadlock) 발생 위험도 있음
- 낙관적(Optimistic) Lock과 비관적(Pessimistic) Lock: 락을 언제 어떻게 적용하느냐에 따라 방식이 달라짐짐

## 💡데드락(교착상태) 방지 방법과 해결 전략 

### 데드락 발생조건
데드락은 다음 네 가지 조건이 동시에 성립할 때 발생할 수 있다.  
1. 상호배제(Mutual Exclusion): 자원을 하나의 트랜잭션(프로세스)만 점유 가능
2. 점유와 대기(Hold and Wait): 점유한 상태에서 다른 자원을 대기
3. 비선점(No Preemption): 점유한 자원이 강제로 뺏기지 않음
4. 순환 대기(Circular Wait): 여러 트랜잭션이 원형으로 자원을 기다림

### 예방 전략
- 상호배제 방지: 가능한 한 자원을 여러 트랜잭션이 공유할 수 있도록 설계.
- 점유와 대기 방지: 트랜잭션이 필요한 모든 자원을 한 번에 요청하도록 설계, 아니면 자원이 하나라도 없으면 모두 반납 후 재시도하게 함
- 비선점 방지: 트랜잭션이 추가 자원을 획득하지 못하면, 점유 중인 자원을 모두 반납하게 하고 다시 시도하도록 만듦
- 순환 대기 방지: 자원에 선후순위를 부여하여 트랜잭션이 자원을 항상 정해진 순서로만 요청할 수 있게 함

### 회피 전략
- 은행원 알고리즘(Banker's Algorithm): 시스템이 항상 “안전 상태”를 유지하도록, 자원 할당 시 향후 모든 트랜잭션이 완료될 수 있을지만 판단 후 할당
- 자원 할당 그래프(Resource Allocation Graph): 그래프의 사이클 발생 여부로 데드락 위험을 회피

### 탐지와 복구
- 탐지: 자원 할당 및 대기 상태를 주기적으로 검사하여 데드락 발생여부 확인, 예: 데드락 감지 알고리즘
- 복구: 데드락 상태일 때 트랜잭션 중 일부를 강제 종료(Kill)하거나 자원 회수(Rollback)로 데드락을 해소

### 실무적 예방 팁
- 트랜잭션 내에서 락 획득 순서를 일관되게 유지
- 가능한 한 트랜잭션을 짧게 유지, 불필요한 락을 최소화
- 행 수준 등 세분화된 락 사용으로 경쟁 최소화.
- 타임아웃 또는 LOCK_TIMEOUT 설정으로 무한 대기 방지

## ❓ QnA

### 🙋‍♂️ Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
💁
1. Optimistic Lock(낙관적 락)
- 데이터 충돌이 드물 것이라 가정하고 락을 미리 걸지 않는 방식
- 데이터를 읽을 때는 아무런 락을 걸지 않고, 실제로 업데이트하는 시점에 버전 정보나 갱신 타임스탬프 등을 활용하여 다른 트랜잭션이 데이터를 변경했는지 확인
- 만약 데이터가 중간에 변경됐다면 트랜잭션을 롤백하거나 재시도
- 주로 읽기 비율이 높고 쓰기 충돌이 거의 없는 환경에서 성능상의 이점이 큼

2. Pessimistic Lock(비관적 락)
- 데이터 충돌이 자주 발생할 것이라 가정하고, 데이터를 읽거나 쓰기 전에 즉시 락을 걸어 다른 트랜잭션의 접근을 차단하는 방식
- 자원 경쟁이 치열하거나 데이터 무결성이 매우 중요한 환경에서 사용
- 데이터 접근 시점부터 락이 걸리므로 데드락 발생 가능성, 시스템 성능 저하 등 부작용이 있지만, 데이터 정합성은 더욱 확실하게 보장할 수 있음.

| 구분            | Optimistic Lock (낙관적 락)                              | Pessimistic Lock (비관적 락)                              |
|-----------------|----------------------------------------------------------|----------------------------------------------------------|
| 충돌 가정       | 충돌이 드물다고 가정                             | 충돌이 자주 발생한다고 가정             |
| 락 적용 시점    | 데이터 갱신(업데이트) 시점에 충돌 체크  | 읽기 또는 쓰기 시작과 동시에 락 적용    |
| 동시성          | 높음                                             | 낮음                                                     |
| 데드락 위험     | 거의 없음                                        | 존재함 (데드락 발생 가능)                |
| 성능            | 읽기 많은 환경에 적합, 성능 유리        | 경쟁 심한 환경에서 정합성 보장           |
| 구현 방법       | 버전 필드, 타임스탬프 사용              | 트랜잭션 또는 SELECT FOR UPDATE 사용     |
| 롤백/재시도     | 충돌 시 트랜잭션 롤백 및 재시도         | 롤백보다 자원 대기(블로킹)                       |
| 적용 사례       | 대규모 트래픽, 충돌 적은 시스템         | 금융 등 데이터 무결성 최우선 환경        |



### 🙋‍♂️ 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?
💁 대부분의 DBMS는 물리적인 Lock(락)을 사용하는 과정에서 트랜잭션이 비정상 종료되더라도 락이 영구적으로 남지 않도록 운영체제와 데이터베이스 차원에서 자동 해제 메커니즘을 제공

<b> DB의 자동 Lock 해제 메커니즘 </b>
- 트랜잭션과 락은 일반적으로 커넥션(세션) 단위로 관리됩니다. 트랜잭션을 수행하던 연결이 강제로 종료되거나 예외가 발생할 경우, 대부분의 DBMS는 해당 세션에 걸린 락을 자동으로 해제한다.
- Deadlock 감지, Lock Timeout 등 내부적인 보호 장치가 마련되어 있어, 일정 시간 이상 점유된 락이나 비정상 세션의 락은 시스템에 의해 해제 및 롤백 처리
- 예를 들어, MySQL의 경우 트랜잭션이 중단되면 rollback이 자동 수행되어 락이 해제됩니다. 비정상 세션의 강제 종료 기능도 제공

<b> 운영상 주의점과 개선책 </b>
- 세션 문제가 반복적으로 발생하거나 자동 해제가 정상적으로 동작하지 않을 경우, 관리자는 세션 상태와 락 정보를 점검하거나 수동으로 세션을 종료(KILL 쿼리 등)할 수 있음
- Lock Timeout, Deadlock Detection 설정을 더욱 명확히 하여, 락이 오랫동안 유지되지 않도록 운용할 수 있음
- 만약 DBMS 레벨에서 영구 락 문제가 발생한다면, 직접적으로 연결 해제, 트랜잭션 롤백, 세션 강제 종료와 같은 방법으로 문제를 해결할 수 있음

